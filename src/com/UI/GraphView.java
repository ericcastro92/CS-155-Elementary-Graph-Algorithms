/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package com.UI;

import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.util.mxConstants;
import com.mxgraph.view.mxGraph;
import com.mxgraph.view.mxStylesheet;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

/**
 *
 * @author ericcastro
 */
public class GraphView extends javax.swing.JFrame 
{   
    private mxGraph graph;
    private Object parent;
    
    /**
     * Creates new form GraphView
     */
    public GraphView(MainView mv, String title) 
    {
        initComponents();
        initCustomComponents();
        addWindowListener(new WindowAdapter()
        {
            @Override
            public void windowClosing(WindowEvent e)
            {
                mv.enableButtons();
            }
        });
        
        graph = new mxGraph();
        buildStyles();
        initializeGraph();
        showAlgorithm();
        
        setTitle(title);
    }
    
    private void initCustomComponents()
    {
        
        //Set up speed slider
        speedSlider.setMaximum(5);
        speedSlider.setMinimum(1);
        speedSlider.setMajorTickSpacing(1);
        speedSlider.setSnapToTicks(true);
        speedSlider.setValue(3);
    }
    
    private void showAlgorithm()
    {
        TimerTask tt = new TimerTask() 
        {
            @Override
            public void run() 
            {
                System.out.println("Resuming");
                traverseGraph();
            }
        };
        
        System.out.println("Waiting");
        Timer timer = new Timer();
        timer.schedule(tt, 3000);//Wait for 3 seconds
    }
    
    private void buildStyles()
    {
        mxStylesheet stylesheet = graph.getStylesheet();
        HashMap<String, Object> style = new HashMap<>();
        
        //Default rounded style
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_ELLIPSE);
        stylesheet.putCellStyle("ROUNDED", style);
        
        //Red rounded style
        style = new HashMap<>();
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_ELLIPSE);
        style.put(mxConstants.STYLE_FILLCOLOR, "#FF0000");
        style.put(mxConstants.STYLE_STROKECOLOR, "#000000");
        stylesheet.putCellStyle("RED_ROUNDED", style);
        
        //Overlay edge
        style = new HashMap<>();
        style.put(mxConstants.STYLE_STROKECOLOR, "#000000");
        stylesheet.putCellStyle("OVERLAY_EDGE", style);
    }

    private void initializeGraph()
    {
        parent = graph.getDefaultParent();

        graph.getModel().beginUpdate();
        try
        {
            Object v1 = graph.insertVertex(parent, null, "A", 20, 20, 80, 30, "ROUNDED");
            Object v2 = graph.insertVertex(parent, null, "B", 240, 150, 80, 30, "ROUNDED");
            graph.insertEdge(parent, null, null, v1, v2);
            graph.insertEdge(parent, null, null, v2, v1);
        }
        finally
        {
            graph.getModel().endUpdate();
        }
        
        mxGraphComponent graphComponent = new mxGraphComponent(graph);
        graphComponent.setDragEnabled(false);
        graphComponent.setEnabled(false);
        graphScrollPane.add(graphComponent);
        graphScrollPane.setViewportView(graphComponent);
    }
    
    Object v3;
    
    private void traverseGraph()
    {
        graph.getModel().beginUpdate();
        try
        {
            v3 = graph.insertVertex(parent, null, "A", 20, 20, 80, 30, "RED_ROUNDED");
        }
        finally
        {
            graph.getModel().endUpdate();
        }
        
        TimerTask tt = new TimerTask() 
        {
            @Override
            public void run() 
            {
                traverseGraphHelper();
            }
        };
        
        System.out.println("Waiting");
        Timer timer = new Timer();
        timer.schedule(tt, 3000);//Wait for 3 seconds
    }
    
    private void traverseGraphHelper()
    {
        graph.getModel().beginUpdate();
        try
        {
            Object v4 = graph.insertVertex(parent, null, "B", 240, 150, 80, 30, "RED_ROUNDED");
            graph.insertEdge(parent, null, null, v3, v4,"OVERLAY_EDGE");
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        speedSlider = new javax.swing.JSlider();
        graphScrollPane = new javax.swing.JScrollPane();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Graph");

        speedSlider.setMajorTickSpacing(1);
        speedSlider.setMaximum(5);
        speedSlider.setMinimum(1);
        speedSlider.setPaintTicks(true);
        speedSlider.setSnapToTicks(true);
        speedSlider.setToolTipText("Select how fast you wouldl like the algorithm to run.");
        speedSlider.setValue(3);

        jLabel1.setText("Fast");

        jLabel2.setText("Slow");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(64, 64, 64)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(speedSlider, javax.swing.GroupLayout.DEFAULT_SIZE, 226, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1)
                .addGap(51, 51, 51))
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(graphScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 408, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(275, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(speedSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addComponent(graphScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 276, Short.MAX_VALUE)
                    .addGap(43, 43, 43)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane graphScrollPane;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JSlider speedSlider;
    // End of variables declaration//GEN-END:variables
}
